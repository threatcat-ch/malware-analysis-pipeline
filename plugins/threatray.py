import argparse
import datetime
import pathlib
import sys
import json
import os
import time
import re
import subprocess
import requests
import logging
from datetime import datetime

from threatray.api import API
from plugins.abstract_plugin import AbstractPlugin
from utils.state import State
from pathlib import Path

class_name = 'Threatray'

class Threatray(AbstractPlugin):
    
    def __init__(self):
        super().__init__()
        self.data = None
        self.threatray_path = ''
        self.threatray_url = State.config['threatray']['url']
        self.threatray_secret_token = State.config['threatray']['secret_token']
        self.type_map = {
                        'domain': 'domain',
                        'hostname': 'hostname',
                        'dst': 'ip-dst|port',
                        'dumped_file': 'filename',
                        'family': 'tag',
                        'md5': 'md5',
                        'sha1': 'sha1',
                        'sha256': 'sha256',
                        'sha512': 'sha512',
                        'target': 'email-attachment',
                        'url': 'url',
                        'tls_ja3': 'ja3-fingerlogging.info-md5',
                        'user-agent': 'user-agent',
                        'username' : 'email-dst',
                        'email_to' : 'email-dst'
                        }

    # Run Threatray 
    def run(self, args):
        logging.info("Run Threatray Plugin")
        todo_path = str(State.path)
        if todo_path:
            # create directory for threatray output
            if not os.path.exists(f"{todo_path}/threatray"):
                os.makedirs(f"{todo_path}/threatray")
                self.threatray_path = f"{todo_path}/threatray/"

        else:
            logging.info("No Threatray Sample")
            return

        file = State.attachment_name
        self.run_threatray(todo_path, file)

        threatray_report = f"{self.threatray_path}threatray_report.json"
        if os.path.exists(threatray_report):
            with open(threatray_report, "r", encoding='utf-8') as f:
                threatray_report_data = f.read()

            self.data = json.loads(threatray_report_data)
            self.get_signature_info()
            
            # If signature.json exists log it
            if os.path.exists(f"{self.threatray_path}signature.json"):
                with open(f"{self.threatray_path}signature.json", 'r') as f:
                    signature_data = json.load(f)
                logging.info(f"Malware Signature Threatray: {signature_data}")
        else:
            logging.info("No Threatray Report")
            return
    

    # Upload file to Threatray and get report/dump/pcap
    def run_threatray(self, todo_path, file):
        
        # Upload file to Threatray
        analysis_data = self.post_file(f"{todo_path}/{file}")
        logging.info(f"{analysis_data}")
        analysis_id = analysis_data['submissions'][0]['analysis']['id']
        logging.info(f"Analysis ID: {analysis_id}")
        task_status = self.get_task_status(f"{analysis_id}")
        
        while task_status != "done":
            time.sleep(60)
            task_status = self.get_task_status(f"{analysis_id}")
            logging.info(f"Task Status: {task_status}")

        # Get Threatray Report
        report = self.get_report(State.sha256, analysis_id)
        logging.info(f"Threatray report downloaded")
        with open(f"{self.threatray_path}threatray_report.json", "w") as f:
            json.dump(report, f)

        # Write HTML report URL to file
        with open(f"{self.threatray_path}/report_url.json", 'w') as f:
            json.dump({'report_url': f"{self.threatray_url}/samples/{State.sha256}/analyses/{analysis_id}"}, f)
            
        
    def post_file(self, file_path:str, label: str = 'test', analysis_mode: str = 'dynamic', enable_network: bool = True,
                timeout: int = 300, priority: int = 9):
        api = API()
        cm = api.get_credentials_manager()

        first_seen = default = time.mktime(datetime.now().timetuple())

        data = {
            'label': label,
            'analysis_mode': analysis_mode,
            'first_seen': int(first_seen),
            'timeout': timeout,
            'environments': [],
            'enable_network': enable_network,
            'priority': priority
        }
        
        files = {'file': open(file_path, 'rb')}
        
        resp = requests.post(f'{cm.get_api_url()}/v1/submissions/samples', data=data, files=files,
                         headers=cm.get_authorization_header())
        
        if resp.status_code != 201:
            try:
                msg = resp.json()["error"]["message"]
            except:
                msg = ''
            logging.info(f'Failed to submit file for analysis {resp.status_code}: {resp.json()["error"]["message"]}')
            return

        data = resp.json()

        if data['submissions']:
            logging.info(f'Submitted file for analysis, created {len(data["submissions"])} submission(s).')
        else:
            logging.info('No submissions were created for the submitted file, the file(s) might be unsupported.')
            return

        cm.logout()

        return data

    def get_task_status(self, analysis_id: str) -> str:

        api = API()
        cm = api.get_credentials_manager()

        resp = requests.get(f'{cm.get_api_url()}/v1/tasks/by-analysis/{analysis_id}', headers=cm.get_authorization_header())

        if resp.status_code != 200:
            logging.info(f'Status code: {resp.json()}')
            return

        submission_data = resp.json()
        cm.logout()

        return submission_data[0]['status']


    def get_report(self, sample_hash: str, analysis_id: str):

        api = API()
        cm = api.get_credentials_manager()

        resp = requests.get(f'{cm.get_api_url()}/v1/samples/{sample_hash}/analyses/{analysis_id}',
                       headers=cm.get_authorization_header())

        if resp.status_code != 200:
            logging.info(f'status code {resp.status_code}')
            logging.info(resp.text)
            return None

        report = resp.json()

        cm.logout()

        return report


    def get_context(self, sample_hash: str, analysis_id: str):

        api = API()
        cm = api.get_credentials_manager()

        resp = requests.get(f'{self.threatray_url}/v1/samples/{sample_hash}/analyses/{analysis_id}',
                        headers=self.threatray_secret_token)

        if resp.status_code != 200:
            logging.info(f'status code {resp.status_code}')
            return None

        report = resp.json()

        cm.logout()

        return report       
        
            
    # Add C2 info to JSON file
    def add_attr(self, field, field_val):
        if not field_val:
            return
        misp_type = self.type_map.get(field)
        # Add attribute to C2 JSON file
        c2_file_name = f"{self.threatray_path}c2.json"
        if os.path.exists(c2_file_name):
            with open(c2_file_name, "r", encoding='utf-8') as f:
                c2_data = json.load(f)
        else:
            c2_data = {}

        if misp_type == 'domain' and field_val.count('.') > 1:
            misp_type = 'hostname'

        with open(c2_file_name, "w", encoding='utf-8') as f:
            if not c2_data:
                c2_data = {misp_type: field_val}
            else:
                c2_data.update({misp_type: field_val})
            json.dump(c2_data, f)

    # Write signature to JSON file
    def add_signature(self, field, field_val):
        signature_file_name = f"{self.threatray_path}signature.json"

        if os.path.exists(signature_file_name):
            with open(signature_file_name, "r") as f:
                signature_data = json.load(f)
        else:
            signature_data = []
        
        with open(signature_file_name, "w") as f:
            misp_type = self.type_map.get(field)
            if misp_type == 'tag':
                tag = self.search_tag(field_val)
                if tag:
                    signature_data.append(tag.strip())
                    json.dump(signature_data, f)
                else:
                    json.dump(signature_data, f)

    # Get MISP Tags
    def search_tag(self, tag):
        # Ignore the misp-galaxy tags
        available_tags = filter(lambda x: not x.startswith('misp-') and not x.startswith('mwdb'), State.tags)
        for misp_tag in available_tags:
            if tag.lower() in misp_tag.lower():
                logging.info(f"Matched Tag: {misp_tag}")
                return misp_tag

    # Get Malware Signature from Threatray JSON report
    def get_signature_info(self):
        labels = [threat['label'] for threat in self.data['sample']['threats']]
        for label in labels:
            self.add_signature('family', label)


    

