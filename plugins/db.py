import json
import os
import time
import logging
import mysql.connector

from mysql.connector import Error
from plugins.abstract_plugin import AbstractPlugin
from utils.state import State
from pathlib import Path

class_name = 'DB'

class DB(AbstractPlugin):
    
    def __init__(self):
        super().__init__()

    def run(self, args):
        logging.info("Run DB Plugin")

        self.db_host = State.config['mariadb']['host']
        self.db_port = State.config['mariadb']['port']
        self.db_user = State.config['mariadb']['user']
        self.db_password = State.config['mariadb']['password']
        self.db_database = State.config['mariadb']['database']
        self.db_table = State.config['mariadb']['table']
        
        # Connect to MariaBD
        try:
            # Establish the connection
            self.connection = mysql.connector.connect(
                host=self.db_host,
                database=self.db_database,
                port=self.db_port,
                user=self.db_user,
                password=self.db_password
            )
            
            if self.connection.is_connected():
                self.db_info = self.connection.get_server_info()
                logging.info(f"Connected to MariaDB Server")
                self.cursor = self.connection.cursor()

        except Error as e:
            print("Error while connecting to MariaDB", e)
            return

        sandboxes_to_scan = State.config['sandbox']['sandbox_list']

        self.todo_path = str(State.path)

        # Check if sha256 hahs exists in database
        self.sample_name = State.attachment_name
        self.md5 = State.md5
        self.sha1 = State.sha1
        self.sha256 = State.sha256
        self.sha512 = State.sha512
        query = f"SELECT * FROM {self.db_table} WHERE sha256 = '{self.sha256}'"
        self.cursor.execute(query)
        record = self.cursor.fetchone()
        if record:
            # Update last_seen with current timestamp
            query = f"UPDATE {self.db_table} SET last_seen = '{time.strftime('%Y-%m-%d %H:%M:%S')}' WHERE sha256 = '{self.sha256}'"
            self.cursor.execute(query)
            self.connection.commit()
            logging.info(f"Record with sha256 {self.sha256} already exists in database")
        else:
            self.insert_db()
        
        # Loop through the sandboxes
        sandboxes = sandboxes_to_scan.split(',')
        # Iterate over the items in the list and process each one
        for sandbox in sandboxes:
            sandbox = sandbox.strip()
            self.get_score(sandbox)
            self.get_signatures(sandbox)
            self.get_c2(sandbox)
            self.get_mutexes(sandbox)

        self.close_db()    

    def get_score(self, sandbox):
        # Read the score json file
        score_file = f"{self.todo_path}/{sandbox}/score.json"
        if os.path.exists(score_file):
            with open(score_file, "r", encoding='utf-8') as f:
                scores = f.read()
            scores = json.loads(scores)
            score = scores.get('score')
            if score:
                query = f"UPDATE {self.db_table} SET score_{sandbox} = {score} WHERE sha256 = '{self.sha256}'"
                self.cursor.execute(query)
                self.connection.commit()
        return


    def get_signatures(self, sandbox):
        # Read the signature json file
        signature_file = f"{self.todo_path}/{sandbox}/signature.json"
        if os.path.exists(signature_file):
            with open(signature_file, "r", encoding='utf-8') as f:
                signatures = f.read()
            signatures = json.loads(signatures)
            # set sandbox signature to variable if not none
            signature = signatures[0]
            if signature:
                query = f"UPDATE {self.db_table} SET signature_{sandbox} = '{signature}' WHERE sha256 = '{self.sha256}'"
                self.cursor.execute(query)
                self.connection.commit()
        return

    def get_mutexes(self, sandbox):
        # Read the mutexes json file
        mutex_file = f"{self.todo_path}/{sandbox}/mutexes.json"
        if os.path.exists(mutex_file):
            with open(mutex_file, "r", encoding='utf-8') as f:
                mutexes = f.read()
            mutexes = json.loads(mutexes)
            if mutexes:
                mutexes = mutexes.get('mutexes',[])
                mutexes_str = ','.join(mutexes)
                query = f"UPDATE {self.db_table} SET signature_{sandbox} = '{mutexes_str}' WHERE sha256 = '{self.sha256}'"
                self.cursor.execute(query)
                self.connection.commit()
        return

    def get_c2(self, sandbox):
        # Read the c2 json file
        c2_file = f"{self.todo_path}/{sandbox}/c2.json"
        if os.path.exists(c2_file):
            with open(c2_file, "r", encoding='utf-8') as f:
                c2 = f.read()
            c2 = json.loads(c2)
            
            if c2:
                value = next(iter(c2.values()))
                query = f"UPDATE {self.db_table} SET c2_{sandbox} = '{value}' WHERE sha256 = '{self.sha256}'"
                self.cursor.execute(query)
                self.connection.commit()
        return
    

    def insert_db(self):
        first_seen = time.strftime('%Y-%m-%d %H:%M:%S')
        last_seen = time.strftime('%Y-%m-%d %H:%M:%S')

       # INSERT it into the database
        query = f"INSERT INTO {self.db_table} (first_seen, last_seen, md5, sha1, sha256, sha512, sample_name, signature_joebox, signature_triage, signature_vmray, signature_threatray, score_joebox, score_triage, score_vmray, score_threatray, report_joebox, report_triage, report_vmray, report_threatray, c2_joebox, c2_triage, c2_vmray, c2_threatray, mutexes_joebox, mutexes_triage, mutexes_vmray, mutexes_threatray) VALUES ('{first_seen}', '{last_seen}', '{self.md5}', '{self.sha1}', '{self.sha256}', '{self.sha512}', '{self.sample_name}', '', '', '', '', 0, 0, 0, 0, '', '', '', '', '', '', '', '', '', '', '', '')"
        self.cursor.execute(query)
        self.connection.commit()
        logging.info(f"Record with sha256 {self.sha256} inserted into database")
       
        return 


    def close_db(self):
        if self.connection.is_connected():
            self.cursor.close()
            self.connection.close()
            logging.info("MariaDB connection is closed")
        return   