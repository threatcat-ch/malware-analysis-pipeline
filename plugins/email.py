import argparse
import datetime
import os
import json
import re
import eml_parser
import shutil
import pathlib
import subprocess
import time
import logging

from hashlib import new
from base64 import b64decode
from plugins.abstract_plugin import AbstractPlugin
from utils.state import State

class_name = 'Email'

class Email(AbstractPlugin):

    def __init__(self):
        super().__init__()
        self.data = {}

    # Run Email plugin
    def run(self, args):
        logging.info("Init Email Plugin")
        # Check if priority directory exists
        if not os.path.exists(State.config['priority']['new_files_dir']):
            os.makedirs(State.config['priority']['new_files_dir'])
        # Check if file is in priority directory
        self.priority_dir = State.config['priority']['new_files_dir']
        self.priority_files = os.listdir(self.priority_dir)
        if self.priority_files:
            self.new_emails_dir = self.priority_dir
        else:
            self.new_emails_dir = State.config['emails']['new_emails_dir']
        self.analysis_dir = State.config['emails']['analysis_dir']
        self.mimetype_email_list = State.config['emails']['mimetype_list'].split(',')
        
        self.oldest_email_full_path = self.parse_new_email()
        logging.info(f"Email Path: {self.oldest_email_full_path}")
        new_analysis_dir = self.create_analysis_dir()
        State.path = pathlib.Path(new_analysis_dir)
        logging.info(f"New Analysis Dir: {new_analysis_dir}")
        if os.path.exists(new_analysis_dir + 'mail.eml'):
            self.extract_attachments(new_analysis_dir)
            with open(new_analysis_dir + 'mail.json', 'w') as f:
                json.dump(self.data, f)
        

    # Extract attachments from new email    
    def extract_attachments(self, new_analysis_dir):
        ep = eml_parser.EmlParser(include_attachment_data=True)
        attachments = ep.decode_email(new_analysis_dir + 'mail.eml')
        for attachment in attachments['attachment']:
            with open(new_analysis_dir + attachment['filename'], 'wb') as f:
                f.write(b64decode(attachment['raw']))
            State.attachment_name = attachment['filename']
        return    


    # Create new analysis dir
    def create_analysis_dir(self):
        dir_today = datetime.datetime.now().strftime("%Y") + '/' + \
                    datetime.datetime.now().strftime("%m") + '/' + \
                    datetime.datetime.now().strftime("%d") + '/'
        if not os.path.exists(self.analysis_dir + dir_today):
            os.makedirs(self.analysis_dir + dir_today)
        list_dir_today = os.listdir(self.analysis_dir + dir_today)
        if list_dir_today:
            sorted_list_dir_today = sorted(list_dir_today, key=int)
            last_dir = sorted_list_dir_today[-1]
            new_dir = int(last_dir) + 1
            new_analysis_dir = self.analysis_dir + dir_today + str(new_dir) + '/'
            os.mkdir(new_analysis_dir)
            if self.oldest_email_full_path:
                if self.check_email_mimelist(self.oldest_email_full_path):
                    shutil.move(self.oldest_email_full_path, new_analysis_dir + 'mail.eml')
                else:
                    shutil.move(self.oldest_email_full_path, new_analysis_dir)
            return new_analysis_dir
        else:
            new_analysis_dir = self.analysis_dir + dir_today + '1' + '/'
            os.mkdir(new_analysis_dir)
            if self.oldest_email_full_path:
                if self.check_email_mimelist(self.oldest_email_full_path):
                    shutil.move(self.oldest_email_full_path, new_analysis_dir + 'mail.eml')
                else:
                    shutil.move(self.oldest_email_full_path, new_analysis_dir)
            return new_analysis_dir


    # Parse new email
    def parse_new_email(self):
        check_if_new_emails = os.listdir(self.new_emails_dir)
        if not check_if_new_emails:
            raise Exception("No email found")
        os.chdir(self.new_emails_dir)
        oldest_email = min(check_if_new_emails, key=os.path.getctime)
        oldest_email_full_path = self.new_emails_dir + oldest_email
        if not self.check_email_mimelist(oldest_email_full_path):
            return oldest_email_full_path
        with open(oldest_email_full_path, 'rb') as fhdl:
            raw_email = fhdl.read()
            ep = eml_parser.EmlParser()
            parsed_eml = ep.decode_email_bytes(raw_email)
            
            # Extract email header information to use it in the MISP plugin
            # Check if there is a subject in the header
            if not parsed_eml.get('header'):
                logging.info("No header found")
                os.rmdir(oldest_email_full_path)
                return

            # Check if there is a subject in the header
            if parsed_eml['header'].get('subject'):
                logging.info("No subject found")
                self.data['email-subject'] = parsed_eml['header']['subject']
            if parsed_eml['header'].get('from'):
                logging.info("No from found")
                self.data['email-src-display-name'] = parsed_eml['header']['from']
            if parsed_eml['header'].get('received'):
                ipv4_regex = r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
                try:
                    ip_match = list(filter(lambda x: re.match(ipv4_regex, x), parsed_eml['header']['received'][-1]['from']))
                    self.data['ip-src'] = ip_match[0]
                except:
                    logging.info("No IP found")

            # Check if there is an attachment
            if parsed_eml.get('attachment'):
                logging.info(f"Attachment/s found: {parsed_eml['attachment']}")
                for filename in parsed_eml['attachment']:
                    self.data['email-attachment'] = filename['filename']
                    logging.info(f"Email Attachment Name: {filename['filename']}")
            else:
                logging.info("No attachment found")
                os.rmdir(oldest_email_full_path)
                raise Exception("No attachments found")
        
        return oldest_email_full_path   

    # Check if file is an executable
    def check_email_mimelist(self, full_path):
        mime_type_check = subprocess.run(['file', '-b', '--mime-type', full_path], stdout=subprocess.PIPE)
        for mime_type in self.mimetype_email_list:
            if mime_type_check.stdout.decode('utf-8').strip() == mime_type:
                logging.info(f"File is in email mimetype list: {full_path}")
                return True
        logging.info(f"File is not in email mimetype list: {full_path}")
        return False