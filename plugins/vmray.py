import argparse
import datetime
import pathlib
import sys
import json
import os
import time
import re
import subprocess
import requests
import logging
import shutil

from plugins.abstract_plugin import AbstractPlugin
from utils.state import State
from pathlib import Path

class_name = 'vmray'

class vmray(AbstractPlugin):
    
    def __init__(self):
        super().__init__()
        self.data = None
        self.vmray_path = ''
        self.vmray_url = State.config['vmray']['url']
        self.type_map = {
                        'domain': 'domain',
                        'hostname': 'hostname',
                        'dst': 'ip-dst|port',
                        'dumped_file': 'filename',
                        'family': 'tag',
                        'md5': 'md5',
                        'sha1': 'sha1',
                        'sha256': 'sha256',
                        'sha512': 'sha512',
                        'target': 'email-attachment',
                        'url': 'url',
                        'tls_ja3': 'ja3-fingerprint-md5',
                        'user-agent': 'user-agent',
                        'username' : 'email-dst',
                        'email_to' : 'email-dst'
                        }

    # Run vmray 
    def run(self, args):
        logging.info("Run vmray Plugin")
        todo_path = str(State.path)
        if todo_path:
            # create directory for vmray output
            if not os.path.exists(f"{todo_path}/vmray"):
                os.makedirs(f"{todo_path}/vmray")
                self.vmray_path = f"{todo_path}/vmray/"

        else:
            logging.info("No vmray Sample")
            return

        file = State.attachment_name
        self.run_vmray(todo_path, file)
        time.sleep(100)
        # Copy vmray report to vmray directory
        if os.path.exists(f"{self.vmray_path}/logs/summary_v2.json"):
            shutil.copy(f"{self.vmray_path}/logs/summary_v2.json", f"{self.vmray_path}vmray_report.json")
            vmray_report = f"{self.vmray_path}vmray_report.json"
            if os.path.exists(vmray_report):
                with open(vmray_report, "r", encoding='utf-8') as f:
                    vmray_report_data = f.read()

                self.data = json.loads(vmray_report_data)
                self.get_signature_info()
            #    self.get_c2_info()
            #    
            #    # If c2.json exists log it
            #    if os.path.exists(f"{self.vmray_path}c2.json"):
            #        with open(f"{self.vmray_path}c2.json", 'r') as f:
            #            c2_data = json.load(f)
            #        logging.info(f"C2 Data vmray: {c2_data}")
            #    
            #    # If signature.json exists log it
            #    if os.path.exists(f"{self.vmray_path}signature.json"):
            #        with open(f"{self.vmray_path}signature.json", 'r') as f:
            #            signature_data = json.load(f)
            #        logging.info(f"Malware Signature vmray: {signature_data}")
            else:
                logging.info("No vmray Report")
                return
        
    # Check if file is executable
    def check_executable(self, todo_path, file):
        mime_type_executable = subprocess.run(['file', '--mime-type', todo_path + '/' + file], stdout=subprocess.PIPE)

        # Check if file is in mimetype list
        for mime_type in State.config['mimetype_to_analyze']['mimetype_list'].split(','):
            if mime_type_executable.stdout.decode('utf-8').strip() in mime_type:
                return True
        return False

    # Upload file to vmray and get report/dump/pcap
    def run_vmray(self, todo_path, file):
        header_api_key = f"api_key {State.config['vmray']['api_key']}"
        #headers = {
        #          'Authorization': header_api_key,
        #          }
        headers = {
                  'Authorization': header_api_key,
                  'reanalyze': "True",
                  'jobrule_entries': "vmray:win10_64:def:winnt_exe"
                  }

        url = State.config['vmray']['url']

        files = {
                'sample_file': open(f"{todo_path}/{file}", 'rb')
                }

        response = requests.post(f"{url}rest/sample/submit", headers=headers, files=files)
        response = response.json()
        error = response["data"]["errors"]
        jobs = response["data"]["jobs"]
        submissions = response["data"]["submissions"]
        samples = response["data"]["samples"]
        submission_id = submissions[0]["submission_id"]
        logging.info(f"vmray Submission ID: {submission_id}")
     
        # Check if vmray is done
        time.sleep(100)
        response = requests.get(f"{url}rest/submission/{submission_id}", headers=headers)
        response = response.json()
        submission_finished = response["data"]["submission_finished"]
        logging.info(f"vmray finished: {submission_finished}")

        while submission_finished == False:
            time.sleep(60)
            response = requests.get(f"{url}rest/submission/{submission_id}", headers=headers)
            response = response.json()
            submission_finished = response["data"]["submission_finished"]
            logging.info(f"vmray finished: {submission_finished}")

        analysis = requests.get(f"{url}rest/analysis/submission/{submission_id}", headers=headers)
        analysis = analysis.json()
        logging.info(f"vmray Analysis: {analysis}")
        analysis_id = analysis["data"][0]["analysis_id"]
        logging.info(f"vmray Analysis ID: {analysis_id}")
#        download_report_summary = requests.get(f"{url}rest/analysis/{analysis_id}/archive/logs/summary_v2.json", headers=headers)
#        save_report_summary = open(f"{self.vmray_path}vmray_report_summary.json", 'wb')
#        save_report_summary.write(download_report_summary.content)
#        save_report_summary.close()
#
#        download_report = requests.get(f"{url}rest/analysis/{analysis_id}/archive/report/stix-report-2-1.json", headers=headers)
#        save_report = open(f"{self.vmray_path}vmray_report.json", 'wb')
#        save_report.write(download_report.content)
#        save_report.close()
#
#        download_pcap = requests.get(f"{url}rest/analysis/{analysis_id}/archive/additional/analysis.pcap", headers=headers)
#        save_pcap = open(f"{self.vmray_path}suricata.pcap", 'wb')
#        save_pcap.write(download_pcap.content)
#        save_pcap.close()
#
#        download_flog = requests.get(f"{url}rest/analysis/{analysis_id}/archive/logs/flog.txt", headers=headers)
#        save_flog = open(f"{self.vmray_path}vmray_flog.json", 'wb')
#        save_flog.write(download_flog.content)
#        save_flog.close()

        download_archive = requests.get(f"{url}rest/analysis/{analysis_id}/archive/", headers=headers)
        save_archive = open(f"{self.vmray_path}files.zip", 'wb')
        save_archive.write(download_archive.content)
        save_archive.close()

        # Unzip Files/Memdumps
        subprocess.run(['7z', 'x', '-pinfected', self.vmray_path + '/files.zip', '-o' + self.vmray_path], stdout=subprocess.PIPE)

    # Add C2 info to JSON file
    def add_attr(self, field, field_val):
        if not field_val:
            return
        misp_type = self.type_map.get(field)
        # Add attribute to C2 JSON file
        c2_file_name = f"{self.vmray_path}c2.json"
        if os.path.exists(c2_file_name):
            with open(c2_file_name, "r", encoding='utf-8') as f:
                c2_data = json.load(f)
        else:
            c2_data = {}

        if misp_type == 'domain' and field_val.count('.') > 1:
            misp_type = 'hostname'

        with open(c2_file_name, "w", encoding='utf-8') as f:
            if not c2_data:
                c2_data = {misp_type: field_val}
            else:
                c2_data.update({misp_type: field_val})
            json.dump(c2_data, f)

    # Write signature to JSON file
    def add_signature(self, field, field_val):
        signature_file_name = f"{self.vmray_path}signature.json"

        if os.path.exists(signature_file_name):
            with open(signature_file_name, "r") as f:
                signature_data = json.load(f)
        else:
            signature_data = []

        # open signature json file
        with open(signature_file_name, "w") as f:
            misp_type = self.type_map.get(field)
            if misp_type == 'tag':
                tag = self.search_tag(field_val)
                
                if tag:
                    # add tag to list
                    signature_data.append(tag.strip())
                    json.dump(signature_data, f)
                else:
                    json.dump(signature_data, f)


    # Get MISP Tags
    def search_tag(self, tag):
        # Ignore the misp-galaxy tags
        available_tags = filter(lambda x: not x.startswith('misp-'), State.tags)
        for misp_tag in available_tags:
            if tag.lower() in misp_tag.lower():
                return misp_tag

    # Get Malware Signature from vmray JSON report
    def get_signature_info(self):
        logging.info("Get Malware Signature from vmray JSON report")
        if os.path.exists(f"{self.vmray_path}malware_configurations"):
            for file in os.listdir(f"{self.vmray_path}malware_configurations"):
                with open(f"{self.vmray_path}malware_configurations/{file}", "r", encoding='utf-8') as f:
                    malware_configurations = f.read()
                self.data = json.loads(malware_configurations)
                sig_detections = self.data.get('parser')

                if not sig_detections:
                    return
                logging.info(f"threatname: {sig_detections}")
                threatname = sig_detections
                self.add_signature('family', threatname.strip())

    # Get C2 info from vmray JSON report
    def get_c2_info(self):
            if not os.path.exists(f"{self.vmray_path}malware_configurations"):
                return
            
            configs = self.data.get('metadata', [])
            for config in self.make_list(configs):

                for key, val in config.items():
                    # if key is value and value is an email address
                    if key == 'value' and '@' in val and key.get.tags('Receipent',[]):
                        self.add_attr('email_from', val)
                    
                    # if key is username and value is an email address
                    if key == 'username' and '@' in val:
                        self.add_attr('email_from', val)