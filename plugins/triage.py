import argparse
import datetime
import pathlib
import sys
import json
import os
import time
import re
import subprocess
import requests
import logging

from plugins.abstract_plugin import AbstractPlugin
from utils.state import State
from pathlib import Path

class_name = 'Triage'

class Triage(AbstractPlugin):
    
    def __init__(self):
        super().__init__()
        self.data = None
        self.triage_path = ''
        self.triage_url = State.config['triage']['url']
        self.triage_report_url = State.config['triage']['report_url']
        self.type_map = {
                        'domain': 'domain',
                        'hostname': 'hostname',
                        'dst': 'ip-dst|port',
                        'dumped_file': 'filename',
                        'family': 'tag',
                        'md5': 'md5',
                        'sha1': 'sha1',
                        'sha256': 'sha256',
                        'sha512': 'sha512',
                        'target': 'email-attachment',
                        'url': 'url',
                        'tls_ja3': 'ja3-fingerprint-md5',
                        'user-agent': 'user-agent',
                        'username' : 'email-dst',
                        'email_to' : 'email-dst'
                        }

    # Run Triage 
    def run(self, args):
        logging.info("Run Triage Plugin")
        todo_path = str(State.path)
        if todo_path:
            # create directory for triage output
            if not os.path.exists(f"{todo_path}/triage"):
                os.makedirs(f"{todo_path}/triage")
                self.triage_path = f"{todo_path}/triage/"

        else:
            logging.info("No Triage Sample")
            return

        file = State.attachment_name
        self.run_triage(todo_path, file)

        triage_report = f"{self.triage_path}triage_report.json"
        if os.path.exists(triage_report):
            with open(triage_report, "r", encoding='utf-8') as f:
                triage_report_data = f.read()

            self.data = json.loads(triage_report_data)
            self.get_signature_info()
            self.get_c2_info()
            
            # If c2.json exists log it
            if os.path.exists(f"{self.triage_path}c2.json"):
                with open(f"{self.triage_path}c2.json", 'r') as f:
                    c2_data = json.load(f)
                logging.info(f"C2 Data Triage: {c2_data}")
            
            # If signature.json exists log it
            if os.path.exists(f"{self.triage_path}signature.json"):
                with open(f"{self.triage_path}signature.json", 'r') as f:
                    signature_data = json.load(f)
                logging.info(f"Malware Signature Triage: {signature_data}")
        else:
            logging.info("No Triage Report")
            return
    
    # Check if file is executable
    def check_executable(self, todo_path, file):
        mime_type_executable = subprocess.run(['file', '--mime-type', todo_path + '/' + file], stdout=subprocess.PIPE)

        # Check if file is in mimetype list
        for mime_type in State.config['mimetype_to_analyze']['mimetype_list'].split(','):
            if mime_type_executable.stdout.decode('utf-8').strip() in mime_type:
                return True
        return False

    # Upload file to Triage and get report/dump/pcap
    def run_triage(self, todo_path, file):
        auth_bearer = f"Bearer {State.config['triage']['api_key']}"
        headers = {
                  'Authorization': auth_bearer
                  }

        files = {
                'file': open(todo_path + '/' + file, 'rb'),
                '_json': (None, '{"kind":"file","interactive":false,"profiles": []}'),
                }

        # Upload file to Triage
        task_id = requests.post(self.triage_url, headers=headers, files=files)
        task_id = task_id.json()
        task_id = task_id['id']
        logging.info("Triage Task ID: " + task_id)
        triage_url = f"{self.triage_url}/{task_id}/behavioral2/"

        # Create a max timer - 10 minutes
        max_time = datetime.datetime.now() + datetime.timedelta(minutes=10)
                
        # Check if Triage is done
        time.sleep(260)
        check_status = requests.get(f"{triage_url}report_triage.json", headers=headers)
        while check_status.status_code != 200:
            if datetime.datetime.now() > max_time:
                raise Exception("Triage Analysis Timeout")
            time.sleep(10)
            check_status = requests.get(f"{triage_url}report_triage.json", headers=headers)
            logging.info(f"Triage Report HTTP Status Code: {check_status.status_code}")

        # Get Triage JSON report
        report_triage = requests.get(f"{triage_url}report_triage.json", headers=headers)
        save_report = open(f"{self.triage_path}triage_report.json", 'w')
        save_report.write(report_triage.text)
        save_report.close()

        # Write HTML report URL to file
        with open(f"{self.triage_path}/report_url.json", 'w') as f:
            json.dump({'report_url': f"{self.triage_report_url}{task_id}"}, f)
        
        # Get Triage PCAP
        pcap_triage = requests.get(f"{triage_url}dump.pcapng", headers=headers)
        save_pcap = open(f"{self.triage_path}suricata.pcap", 'wb')
        save_pcap.write(pcap_triage.content)
        save_pcap.close()

        # Load Triage JSON Report
        with open(f"{self.triage_path}triage_report.json") as f:
            data = json.load(f)
            if not os.path.exists(f"{self.triage_path}files"):
                os.makedirs(f"{self.triage_path}files")
            if not os.path.exists(f"{self.triage_path}memory"):
                os.makedirs(f"{self.triage_path}memory")
            # get all memory dumps and files
            for i in data['dumped']:
                # get memory dump and files
                dump = requests.get(f"{triage_url}{i['name']}", headers=headers)

                # save memory dump or files
                save_dump = open(f"{self.triage_path}{i['name']}", 'wb')
                save_dump.write(dump.content)
                save_dump.close()

    # Add C2 info to JSON file
    def add_attr(self, field, field_val):
        if not field_val:
            return
        misp_type = self.type_map.get(field)
        # Add attribute to C2 JSON file
        c2_file_name = f"{self.triage_path}c2.json"
        if os.path.exists(c2_file_name):
            with open(c2_file_name, "r", encoding='utf-8') as f:
                c2_data = json.load(f)
        else:
            c2_data = {}

        if misp_type == 'domain' and field_val.count('.') > 1:
            misp_type = 'hostname'

        with open(c2_file_name, "w", encoding='utf-8') as f:
            if not c2_data:
                c2_data = {misp_type: field_val}
            else:
                c2_data.update({misp_type: field_val})
            json.dump(c2_data, f)

    # Write signature to JSON file
    def add_signature(self, field, field_val):
        signature_file_name = f"{self.triage_path}signature.json"

        if os.path.exists(signature_file_name):
            with open(signature_file_name, "r") as f:
                signature_data = json.load(f)
        else:
            signature_data = []

        # open signature json file
        with open(signature_file_name, "w") as f:
            misp_type = self.type_map.get(field)
            if misp_type == 'tag':
                tag = self.search_tag(field_val)
                
                if tag:
                    # add tag to list
                    signature_data.append(tag.strip())
                    json.dump(signature_data, f)
                else:
                    json.dump(signature_data, f)

    # Get MISP Tags
    def search_tag(self, tag):
        # Ignore the misp-galaxy tags
        available_tags = filter(lambda x: not x.startswith('misp-'), State.tags)
        for misp_tag in available_tags:
            if tag.lower() in misp_tag.lower():
                return misp_tag

    # Get Malware Signature from Triage JSON report
    def get_signature_info(self):
        analysis = self.data.get('analysis', {})
        tags = analysis.get('tags', [])
        for tag in tags:
            if tag.startswith('family'):
                self.add_signature('family', tag.split(':')[1])

    # Get C2 credentials from Triage JSON report
    def get_c2_credentials(self, data):
        credentials = data.get('credentials', [])
        if not isinstance(credentials, list):
            credentials = [credentials]
        for cred in credentials:
            proto = cred.get('protocol', '')
            proto_comment = 'FTP' if proto == 'ftp' else 'Email'

            username = cred.get('username')
            if username:
                self.add_attr('username', username)

            email_to = cred.get('email_to')
            if email_to:
                self.add_attr('email_to', email_to)

            host = cred.get('host')
            if host:
                attr_type = 'url' if re.match(r'(http|https|ftp)://', host) else 'hostname'
                self.add_attr(attr_type, host)

    # Get C2 info from Triage JSON report
    def get_c2_info(self):
        extracted = self.data.get('extracted', [])
        for ext in extracted:
            dropper = ext.get('dropper', {})

            urls = dropper.get('urls', [])
            for url in urls:
                self.add_attr('url', url['url'], url['type'])

            config = ext.get('config', {})

            c2_config = config.get('c2', [])
            for url in c2_config:
                ip_port = re.fullmatch(r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}:[0-9]+', url)
                if ip_port:
                    self.add_attr('dst', url)
                else:
                    self.add_attr('url', url)

            self.get_c2_credentials(config)
            self.get_c2_credentials(ext)