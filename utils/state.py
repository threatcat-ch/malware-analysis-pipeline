import pymisp
import requests
import json
import os
import sys
import pathlib
import logging
import traceback
import configparser
import hashlib
import subprocess

from typing import Optional
from dataclasses import dataclass
from configparser import ConfigParser
from pymisp import MISPEvent, PyMISP, MISPTag
from typing import List

class State:
    config: ConfigParser
    path: Optional[pathlib.Path]
    attachment_name: Optional[str]
    misp: PyMISP
    tags: List[MISPTag]
    event: MISPEvent

    @staticmethod
    def init() -> None:
        root_path = os.getcwd()
        cfg_file = os.path.join(root_path, 'config.cfg')
        State._init_config(cfg_file)
        State._init_misp()
        State._init_tags()
        State.start_logging(cfg_file)

    @staticmethod
    def _init_config(file) -> None:
    
        if not os.path.isfile(file):
            logging.critical("Config file not found: %s", file)
            exit(1)

        State.config = ConfigParser()
        State.config.read(file)
        State.path = None
        State.progress_cause = "Undefined"
        State.md5 = None
        State.sha256 = None
        State.priority = False

    @staticmethod
    def _init_misp() -> None:
        misp_config = State.config['misp']
        verifycert = misp_config['verifycert']
        if verifycert and verifycert.lower() == 'false':
            verifycert = False
        if verifycert and verifycert.lower() == 'true':
            verifycert = True
        State.misp = PyMISP(misp_config["url"], misp_config["key"], verifycert)

    @staticmethod
    def _init_tags() -> None:
        tags = State.misp.tags(pythonify=True)
        State.tags =  {tag["name"]: tag["id"] for tag in tags}

    @staticmethod
    def _my_handler(type_, value, tb):
        sst = traceback.format_exception(type_, value, tb)
        logging.critical("Uncaught Exception:\n" + ''.join(sst))

    @staticmethod
    def _reset_state() -> None:
        State.path = None
        State.attachment_name = ''
        State.md5 = None
        State.sha256 = None
        State.priority = False

    @staticmethod
    def start_logging(cfg_file):
        the_config = configparser.RawConfigParser()
        try:
            the_config.read_file(open(cfg_file))
        except IOError:
            sys.stderr.write("Can't read %s " % os.path.abspath(cfg_file))
            sys.exit(1)
    
        config = the_config
        logging.__defaultFormatter = logging.Formatter(u"%(message)s")
        log_file = config.get('logging', 'file')
        log_level_file = config.get('logging', 'file_level')
        log_level_stdout = config.get('logging', 'stdout_level')
        log = logging.getLogger()
        log.setLevel(log_level_file)

        ch = logging.StreamHandler()
        ch.setLevel(log_level_stdout)
        log_folder = os.path.abspath(os.path.dirname(log_file))
        if not os.path.exists(log_folder):
            logging.warning("log directory does not exist, creating (%s)", log_folder)
            os.makedirs(log_folder)

        fh = logging.FileHandler(log_file, encoding='utf-8')
        fh.setLevel(log_level_file)
        log.addHandler(ch)
        log.addHandler(fh)
        ch_fmt = logging.Formatter(config.get('logging', 'stdout_fmt'))
        fh_fmt = logging.Formatter(config.get('logging', 'file_fmt'))

        ch.setFormatter(ch_fmt)
        fh.setFormatter(fh_fmt)
        logging.getLogger("requests").setLevel(logging.WARNING)
        logging.getLogger("urllib3").setLevel(logging.WARNING)

    @staticmethod
    # Check if file is executable
    def check_executable(self, todo_path, file):
        mime_type_executable = subprocess.run(['file', '-b',  '--mime-type', todo_path + '/' + file], stdout=subprocess.PIPE)
        # Check if file is in mimetype list
        for mime_type in State.config['mimetype_executable']['mimetype_list'].split(','):
            logging.info(f"File Mime Type: {mime_type_executable.stdout.decode('utf-8').strip()}")
            if mime_type_executable.stdout.decode('utf-8').strip() == mime_type:
                logging.info(f"File is executable: {file}")
                return True
        return False

    @staticmethod
    def calculate_md5(file_path):
        md5 = hashlib.md5()
        with open(file_path, 'rb') as file:
            # Read the file in chunks to avoid memory issues with large files
            for chunk in iter(lambda: file.read(4096), b''):
                md5.update(chunk)
        return md5.hexdigest()

    @staticmethod
    def calculate_sha1(file_path):
        sha1 = hashlib.sha1()
        with open(file_path, 'rb') as file:
            # Read the file in chunks to avoid memory issues with large files
            for chunk in iter(lambda: file.read(4096), b''):
                sha1.update(chunk)
        return sha1.hexdigest()

    @staticmethod
    def calculate_sha256(file_path):
        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as file:
            # Read the file in chunks to avoid memory issues with large files
            for chunk in iter(lambda: file.read(4096), b''):
                sha256.update(chunk)
        return sha256.hexdigest()

    @staticmethod
    def calculate_sha384(file_path):
        sha384 = hashlib.sha384()
        with open(file_path, 'rb') as file:
            # Read the file in chunks to avoid memory issues with large files
            for chunk in iter(lambda: file.read(4096), b''):
                sha384.update(chunk)
        return sha384.hexdigest()

    @staticmethod
    def calculate_sha512(file_path):
        sha512 = hashlib.sha512()
        with open(file_path, 'rb') as file:
            # Read the file in chunks to avoid memory issues with large files
            for chunk in iter(lambda: file.read(4096), b''):
                sha512.update(chunk)
        return sha512.hexdigest()


State.init()